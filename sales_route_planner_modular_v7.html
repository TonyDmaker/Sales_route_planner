<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Sales Route Planner â€” Modular v7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .panel {
      position: absolute; z-index: 1000; background: rgba(255,255,255,0.98);
      border-radius: 12px; padding: 12px; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15); font-size: 14px;
    }
    .legend { top: 10px; left: 10px; }
    .toolbar { top: 60px; right: 10px; width: 320px; max-width: 92vw; max-height: 70vh; overflow: auto; display: none; }
    .toolbar.show { display: block; }
    .row { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
    .swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #0002; }
    .btn {
      display: inline-block; padding: 6px 10px; margin: 2px 4px 2px 0; border: 1px solid #ddd; border-radius: 8px;
      background: #f7f7f7; cursor: pointer; user-select: none;
    }
    .btn.active { background: #e5f1ff; border-color: #b3d2ff; }
    .section-title { font-weight:700; margin-top:8px; }
    .popup-form label { display:block; margin: 6px 0 2px; font-weight: 600; }
    .popup-form input, .popup-form select, .popup-form textarea {
      width: 100%; box-sizing: border-box; padding: 6px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px;
    }
    .popup-actions { display:flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .marker-dot { width: 18px; height: 18px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5); }
    .hint {
      position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
      background: rgba(0,0,0,0.75); color:white; padding:6px 10px; border-radius:8px; font-size:12px;
    }
    .palette {
      position: absolute; z-index: 1100; background: white; border-radius: 12px; padding: 8px;
      display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.25); border: 1px solid #0001;
    }
    .palette .item {
      width: 44px; height: 44px; border-radius: 50%; border: 2px solid white;
      box-shadow: 0 0 4px rgba(0,0,0,0.2); margin: 6px; display: inline-flex; align-items:center; justify-content:center; font-size:22px;
    }
    .palette .item.color { }
    .palette .item.selected { outline: 3px solid rgba(0,0,0,0.25); }
    .flex { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }

    .fab {
      position: absolute; top: 10px; right: 10px; z-index: 1101;
      width: 44px; height: 44px; border-radius: 50%; border: none;
      background: #111; color: #fff; font-size: 22px; line-height: 44px; text-align: center;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3); cursor: pointer;
    }

    .toast {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.65); color: #fff; padding: 6px 10px; border-radius: 8px; font-size: 12px;
      display:none; z-index: 1200;
    }

    /* Car drag ghost following finger with offset */
    .car-ghost {
      position: absolute; z-index: 1200; width: 30px; height: 30px;
      transform: translate(-24px, -36px); /* offset up/left so you can see placement point */
      display: none;
      pointer-events: none;
      background: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <button id="menuBtn" class="fab" title="Settings">â˜°</button>
  <div id="toast" class="toast"></div>
  <img id="carGhost" class="car-ghost" alt="car ghost" />

  <div class="panel legend" id="legendPanel">
    <div style="font-weight:700;margin-bottom:6px;">Legend</div>
    <div class="row"><span class="swatch" style="background:#666;"></span> Not visited</div>
    <div class="row"><span class="swatch" style="background:#2ecc71;"></span> Visited</div>
    <div class="row"><span class="swatch" style="background:#e74c3c;"></span> No soliciting</div>
    <div class="row"><span class="swatch" style="background:#3498db;"></span> Follow-up</div>
    <div class="row"><span class="swatch" style="background:#f1c40f;"></span> Wants to buy</div>
    <div class="row"><span style="width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center;font-size:16px;margin-right:8px;">ðŸš—</span> Parking</div>
  </div>

  <div class="panel toolbar" id="settingsPanel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:700;">Settings</div>
      <button class="btn" id="closeSettings">Close</button>
    </div>

    <div class="section-title">Feature toggles</div>
    <label><input type="checkbox" id="tglLongPress" checked> Longâ€‘press to place pin</label>
    <label><input type="checkbox" id="tglRoute" checked> Route tools (add/finish/clear)</label>
    <label><input type="checkbox" id="tglProgress" checked> Show progress coloring along route</label>
    <label><input type="checkbox" id="tglAutoVisit" checked> Autoâ€‘mark pins visited when route passes</label>
    <label><input type="checkbox" id="tglLegend" checked> Show legend</label>
    <label><input type="checkbox" id="tglTapDetails" checked> Tap marker opens details popup</label>

    <div class="section-title">Controls</div>
    <div class="row flex">
      <button class="btn" id="routeAddBtn">Route: Add points</button>
      <button class="btn" id="routeFinishBtn">Finish route</button>
      <button class="btn" id="routeClearBtn">Clear route</button>
    </div>

    <div class="section-title">Parking</div>
    <div class="row flex">
      <button class="btn" id="setParkingGPSBtn">Set Parking (my GPS)</button>
      <button class="btn" id="clearParkingBtn">Clear Parking</button>
      <button class="btn" id="centerOnCarBtn">Center on Car</button>
    </div>

    <div class="section-title">Perimeter</div>
    <div class="row flex">
      <button class="btn" id="drawPerimeterBtn">Draw perimeter</button>
      <button class="btn" id="clearPerimeterBtn">Clear perimeter</button>
      <button class="btn" id="autoRouteBtn">Autoâ€‘route within perimeter</button>
    </div>

    <div class="section-title">Pins</div>
    <div class="row flex">
      <button class="btn" id="exportBtn">Export Pins</button>
      <button class="btn" id="importBtn">Import Pins</button>
      <input type="file" id="importFile" accept="application/json" style="display:none;" />
      <button class="btn" id="clearPinsBtn">Clear Pins</button>
    </div>

    <div class="section-title">Thresholds</div>
    <div class="row">Autoâ€‘visit distance (m): <input id="autoVisitInput" type="number" min="1" max="200" value="35" style="width:70px; padding:4px;"></div>
    <div class="row">Longâ€‘press hold (ms): <input id="longPressInput" type="number" min="200" max="60000" value="1000" style="width:90px; padding:4px;"></div>
  </div>

  <div id="hint" class="hint" style="display:none;">Longâ€‘press, drag to a color (or ðŸš—), release to drop</div>
  <div id="palette" class="palette"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ===== Helpers & constants =====
    const STATUS = {
      NOT_VISITED: { key:'NOT_VISITED', label: 'Not visited', color: '#666666' },
      VISITED: { key:'VISITED', label: 'Visited', color: '#2ecc71' },
      NO_SOLICITING: { key:'NO_SOLICITING', label: 'No soliciting', color: '#e74c3c' },
      FOLLOW_UP: { key:'FOLLOW_UP', label: 'Follow-up', color: '#3498db' },
      WANTS_TO_BUY: { key:'WANTS_TO_BUY', label: 'Wants to buy', color: '#f1c40f' }
    };
    const STATUS_LIST = [STATUS.NOT_VISITED, STATUS.VISITED, STATUS.NO_SOLICITING, STATUS.FOLLOW_UP, STATUS.WANTS_TO_BUY];
    const STORAGE_PINS = 'srp_mod_pins_v7';
    const STORAGE_ROUTE = 'srp_mod_route_v2';
    const STORAGE_PARK = 'srp_parking_v2';
    const STORAGE_PERIM = 'srp_perimeter_v1';

    function makeDot(color) {
      return L.divIcon({ className: 'custom-dot',
        html: '<div class="marker-dot" style="background:'+color+'"></div>',
        iconSize: [18,18], iconAnchor: [9,9], popupAnchor: [0,-9]
      });
    }
    function carIcon() {
      return L.divIcon({ className: 'car-icon',
        html: 'ðŸš—', iconSize: [24,24], iconAnchor: [12,12]
      });
    }
    function newId() { return 'p_' + Date.now() + '_' + Math.floor(Math.random()*1e6); }
    function escapeHtml(str){return (str||'').replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}
    function distM(a,b){ const R=6371000,toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2); const A=s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2; return 2*R*Math.asin(Math.sqrt(A)); }
    function toast(msg, ms=900){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }

    // ===== Map init =====
    const map = L.map('map').fitWorld();
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OpenStreetMap contributors' }).addTo(map);
    let youAreHere=null;
    map.locate({ setView:true, maxZoom:18 });
    map.on('locationfound', e=>{ if(!youAreHere){ youAreHere=L.marker(e.latlng).addTo(map).bindPopup('You are here'); } });

    // ===== State =====
    const pins = new Map();
    function savePins(){ localStorage.setItem(STORAGE_PINS, JSON.stringify(Array.from(pins.values()).map(({_marker,_chain,...rest})=>rest))); }
    function loadPins(){ try{ return JSON.parse(localStorage.getItem(STORAGE_PINS)||'[]'); }catch{ return []; } }
    loadPins().forEach(o=>{ const p={...o}; pins.set(p.id,p); createMarker(p); });

    let routePoints = loadRoute();
    let routePoly=null, progressPoly=null;
    function saveRoute(){ localStorage.setItem(STORAGE_ROUTE, JSON.stringify(routePoints)); }
    function loadRoute(){ try{ return JSON.parse(localStorage.getItem(STORAGE_ROUTE)||'[]'); }catch{ return []; } }

    // Parking
    let parking = loadParking();
    let carMarker = null;
    const carGhost = document.getElementById('carGhost');
    carGhost.src = 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30"><text x="0" y="20" font-size="20">ðŸš—</text></svg>');
    function saveParking(){ localStorage.setItem(STORAGE_PARK, JSON.stringify(parking)); }
    function loadParking(){ try{ return JSON.parse(localStorage.getItem(STORAGE_PARK)||'null'); }catch{ return null; } }
    function renderParking(){
      if(carMarker){ map.removeLayer(carMarker); carMarker=null; }
      if(parking){ carMarker = L.marker(parking, {icon: carIcon(), interactive:true}).addTo(map); attachCarDragHandlers(); }
    }

    // Perimeter
    let perimeter = loadPerimeter();
    let perimeterPoly = null;
    function savePerimeter(){ localStorage.setItem(STORAGE_PERIM, JSON.stringify(perimeter)); }
    function loadPerimeter(){ try{ return JSON.parse(localStorage.getItem(STORAGE_PERIM)||'null'); }catch{ return null; } }
    function renderPerimeter(){
      if(perimeterPoly){ map.removeLayer(perimeterPoly); perimeterPoly=null; }
      if(perimeter && perimeter.length>1){
        perimeterPoly = L.polyline(perimeter, {color:'#2980b9', weight:3, opacity:0.8}).addTo(map);
      }
    }

    // ===== Route render =====
    function renderRoute(){
      if(routePoly){ map.removeLayer(routePoly); routePoly=null; }
      if(progressPoly){ map.removeLayer(progressPoly); progressPoly=null; }
      if(routePoints.length<2) return;
      routePoly = L.polyline(routePoints, {color:'#8e44ad', weight:5, opacity:0.75}).addTo(map);
      if(document.getElementById('tglProgress').checked){
        progressPoly = L.polyline([], {color:'#27ae60', weight:6, opacity:0.9}).addTo(map);
      }
      saveRoute();
    }

    // ===== Pins: create/update =====
    function markerPopupHtml(p){
      return `
        <div class="popup-form">
          <label>Label</label>
          <input type="text" id="title_${p.id}" value="${escapeHtml(p.title||'')}" placeholder="e.g., 123 Main St"/>
          <label>Status</label>
          <select id="status_${p.id}">
            ${Object.values(STATUS).map(s=>`<option value="${s.key}" ${p.status===s.key?'selected':''}>${s.label}</option>`).join('')}
          </select>
          <label>Notes</label>
          <textarea id="notes_${p.id}" rows="3">${escapeHtml(p.notes||'')}</textarea>
          <label><input type="checkbox" id="keep_${p.id}" ${p.keepUnvisited?'checked':''}/> Keep as Unvisited (donâ€™t auto-change)</label>
          <div class="popup-actions">
            <button class="btn" data-action="save" data-id="${p.id}">Save</button>
            <button class="btn" data-action="visited" data-id="${p.id}">Mark Visited</button>
            <button class="btn" data-action="delete" data-id="${p.id}" style="background:#ffecec;">Delete</button>
            <button class="btn" data-action="setParking">Set Parking (my GPS)</button>
          </div>
        </div>`;
    }
    function attachPopupHandlers(marker,p){
      const el = marker.getPopup().getElement(); if(!el) return;
      el.querySelectorAll('button[data-action]').forEach(btn=>{
        btn.addEventListener('click',()=>{
          const action = btn.getAttribute('data-action');
          if(action==='save'){
            p.title = el.querySelector('#title_'+p.id).value.trim();
            p.status = el.querySelector('#status_'+p.id).value;
            p.notes = el.querySelector('#notes_'+p.id).value.trim();
            p.keepUnvisited = el.querySelector('#keep_'+p.id).checked;
            updateMarker(p); savePins();
            marker.setPopupContent(markerPopupHtml(p)); attachPopupHandlers(marker,p);
          } else if(action==='visited'){
            p.status='VISITED'; updateMarker(p); savePins();
            marker.setPopupContent(markerPopupHtml(p)); attachPopupHandlers(marker,p);
          } else if(action==='delete'){
            map.removeLayer(marker); pins.delete(p.id); savePins();
          } else if(action==='setParking'){
            setParkingAtGPS();
          }
        });
      });
    }
    function createMarker(p){
      const m = L.marker([p.lat,p.lng], {icon: makeDot((Object.values(STATUS).find(s=>s.key===p.status)||STATUS.NOT_VISITED).color)});
      if(document.getElementById('tglTapDetails').checked){
        m.bindPopup(markerPopupHtml(p));
        m.on('popupopen',()=>attachPopupHandlers(m,p));
      }
      p._marker = m; m.addTo(map);
    }
    function updateMarker(p){
      if(p._marker){
        p._marker.setIcon(makeDot((Object.values(STATUS).find(s=>s.key===p.status)||STATUS.NOT_VISITED).color));
        if(document.getElementById('tglTapDetails').checked && !p._marker.getPopup()){
          p._marker.bindPopup(markerPopupHtml(p)); p._marker.on('popupopen',()=>attachPopupHandlers(p._marker,p));
        }
        if(!document.getElementById('tglTapDetails').checked && p._marker.getPopup()){
          p._marker.unbindPopup();
        }
      }
    }

    // ===== Palette with ðŸš— option =====
    const palette = document.getElementById('palette');
    function buildPalette(){
      palette.innerHTML = ''
        + STATUS_LIST.map(s=>`<div class="item color" data-type="status" data-key="${s.key}" style="background:${s.color}" title="${s.label}"></div>`).join('')
        + `<div class="item" data-type="car" title="Set Parking at GPS">ðŸš—</div>`;
    }
    function showPalette(pt){ buildPalette(); palette.style.left=(pt.x-130)+'px'; palette.style.top=(pt.y-80)+'px'; palette.style.display='block'; if(navigator.vibrate){try{navigator.vibrate(10)}catch(e){}} }
    function hidePalette(){ palette.style.display='none'; }
    function selectFromPoint(clientX, clientY){
      const el = document.elementFromPoint(clientX, clientY);
      return (el && el.dataset) ? {type: el.dataset.type || (el.textContent==='ðŸš—'?'car':null), key: el.dataset.key||null} : {type:null,key:null};
    }

    // ===== Longâ€‘press gesture (pointer events) =====
    const MOVE_TOL_PX=8;
    let pressTimer=null, pressing=false, pressStartPt=null, pressLatLng=null;
    const mapContainer = map.getContainer();
    function startPress(ev){
      if(!document.getElementById('tglLongPress').checked || routeAddMode) return;
      pressing=true;
      pressStartPt = map.mouseEventToContainerPoint(ev);
      pressLatLng = map.containerPointToLatLng(pressStartPt);
      const holdMs=parseInt(document.getElementById('longPressInput').value||'1000',10);
      clearTimeout(pressTimer);
      pressTimer=setTimeout(()=>{ if(pressing){ showPalette(pressStartPt); freezeMap(true); } }, holdMs);
    }
    function movePress(ev){
      if(!pressing) return;
      const pt = map.mouseEventToContainerPoint(ev);
      const moved = Math.hypot(pt.x-pressStartPt.x, pt.y-pressStartPt.y) > MOVE_TOL_PX;
      if(moved && palette.style.display==='none'){ cancelPress(); }
      if(palette.style.display!=='none'){
        ev.preventDefault();
      }
    }
    function endPress(ev){
      if(palette.style.display!=='none'){
        const pick = selectFromPoint(ev.clientX, ev.clientY);
        if(pick.type==='status'){
          const p = {id:newId(), lat:pressLatLng.lat, lng:pressLatLng.lng, title:'', notes:'', status: pick.key, keepUnvisited:false};
          pins.set(p.id,p); createMarker(p); savePins();
          toast('Pin added');
        } else if(pick.type==='car'){
          setParkingAtGPS();
        }
        hidePalette(); freezeMap(false);
      }
      cancelPress();
    }
    function cancelPress(){ pressing=false; clearTimeout(pressTimer); }
    mapContainer.addEventListener('pointerdown', ev=>{ if(isClickInsideUI(ev.target)) return; startPress(ev); });
    mapContainer.addEventListener('pointermove', ev=>{ movePress(ev); });
    mapContainer.addEventListener('pointerup', ev=>{ endPress(ev); });
    mapContainer.addEventListener('pointercancel', ()=>{ cancelPress(); hidePalette(); freezeMap(false); });

    // ===== Settings show/hide =====
    const settingsPanel=document.getElementById('settingsPanel');
    const menuBtn=document.getElementById('menuBtn');
    const closeBtn=document.getElementById('closeSettings');
    menuBtn.addEventListener('click', ()=>settingsPanel.classList.toggle('show'));
    closeBtn.addEventListener('click', ()=>settingsPanel.classList.remove('show'));
    function isClickInsideUI(target){
      return target.closest && (target.closest('.toolbar') || target.closest('.legend') || target.closest('.palette') || target.closest('.fab') || target.closest('.leaflet-control'));
    }
    document.addEventListener('pointerdown', e=>{ if(!isClickInsideUI(e.target)) settingsPanel.classList.remove('show'); }, {passive:true});

    // ===== Route controls =====
    let routeAddMode=false;
    document.getElementById('routeAddBtn').addEventListener('click', ()=>{
      routeAddMode=!routeAddMode;
      document.getElementById('routeAddBtn').classList.toggle('active', routeAddMode);
    });
    document.getElementById('routeFinishBtn').addEventListener('click', ()=>{ 
      // close to car if exists
      if(parking && routePoints.length>0){
        const last = routePoints[routePoints.length-1];
        const d = distM(last, parking);
        if(d>5) routePoints.push(parking);
      }
      renderRoute(); 
    });
    document.getElementById('routeClearBtn').addEventListener('click', ()=>{ routePoints=[]; renderRoute(); });

    map.on('click', e=>{
      if(routeAddMode && document.getElementById('tglRoute').checked){
        if(routePoints.length===0 && parking){ routePoints.push(parking); }
        routePoints.push(e.latlng); renderRoute();
      }
    });

    // ===== Car placement and dragging with offset ghost =====
    let carDragActive=false;
    function attachCarDragHandlers(){
      if(!carMarker || !carMarker._icon) return;
      const icon = carMarker._icon;
      icon.style.cursor='grab';
      icon.addEventListener('pointerdown', ev=>{
        // long-press to start drag
        let t=null; const startPt={x:ev.clientX,y:ev.clientY};
        const hold=700;
        const onMove=(mv)=>{
          if(!t) return;
          if(Math.hypot(mv.clientX-startPt.x, mv.clientY-startPt.y)>6){ /* keep waiting */ }
        };
        const onUp=()=>{ clearTimeout(t); window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); };
        t=setTimeout(()=>{
          carDragActive=true; if(navigator.vibrate){try{navigator.vibrate(8)}catch(e){}}
          carGhost.style.display='block'; carGhost.style.left=ev.clientX+'px'; carGhost.style.top=ev.clientY+'px';
          freezeMap(true);
          window.addEventListener('pointermove', dragMove);
          window.addEventListener('pointerup', dragEnd);
        }, hold);
        window.addEventListener('pointermove', onMove, {passive:true});
        window.addEventListener('pointerup', onUp, {passive:true});
      });
    }
    function dragMove(ev){
      if(!carDragActive) return;
      carGhost.style.left = ev.clientX+'px';
      carGhost.style.top  = ev.clientY+'px';
      ev.preventDefault();
    }
    function dragEnd(ev){
      if(!carDragActive) return;
      carDragActive=false;
      carGhost.style.display='none';
      const pt = map.mouseEventToContainerPoint(ev);
      const ll = map.containerPointToLatLng(pt);
      parking = {lat: ll.lat, lng: ll.lng}; saveParking(); renderParking();
      freezeMap(false);
    }

    function setParkingAtGPS(){
      if(!youAreHere){ toast('GPS not ready'); return; }
      parking = youAreHere.getLatLng(); saveParking(); renderParking(); toast('Parking set');
    }

    // ===== Perimeter drawing (robust) =====
    let drawMode=false, drawing=false, drawPts=[];
    const drawBtn=document.getElementById('drawPerimeterBtn');
    drawBtn.addEventListener('click', ()=>{
      drawMode = !drawMode;
      drawBtn.classList.toggle('active', drawMode);
      if(!drawMode){ endDrawing(); }
    });
    document.getElementById('clearPerimeterBtn').addEventListener('click', ()=>{
      perimeter=null; renderPerimeter(); savePerimeter();
    });

    function freezeMap(yes){
      if(yes){
        map.dragging.disable(); map.scrollWheelZoom.disable(); map.doubleClickZoom.disable(); map.boxZoom.disable(); map.keyboard.disable();
        map.getContainer().style.touchAction='none';
      } else {
        map.dragging.enable(); map.scrollWheelZoom.enable(); map.doubleClickZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();
        map.getContainer().style.touchAction='';
      }
    }

    function startDrawing(ev){
      drawing=true; drawPts=[];
      const ll = map.containerPointToLatLng(map.mouseEventToContainerPoint(ev));
      drawPts.push(ll);
      freezeMap(true);
      if(!perimeterPoly){ perimeterPoly = L.polyline([], {color:'#2980b9', weight:3, opacity:0.9}).addTo(map); }
      updateDrawing(ev);
    }
    function updateDrawing(ev){
      if(!drawing) return;
      ev.preventDefault();
      const ll = map.containerPointToLatLng(map.mouseEventToContainerPoint(ev));
      const last = drawPts[drawPts.length-1];
      if(!last || distM(last, ll) > 1){ // add every ~1m to keep smooth
        drawPts.push(ll);
        perimeterPoly.setLatLngs(drawPts);
      }
    }
    function endDrawing(){
      if(!drawing) return;
      drawing=false;
      perimeter = drawPts.slice();
      savePerimeter(); renderPerimeter();
      freezeMap(false);
    }

    // Attach pointer events for drawing to map container
    mapContainer.addEventListener('pointerdown', ev=>{
      if(!drawMode) return;
      if(isClickInsideUI(ev.target)) return;
      startDrawing(ev);
    });
    mapContainer.addEventListener('pointermove', ev=>{
      if(!drawMode) return;
      updateDrawing(ev);
    });
    window.addEventListener('pointerup', ev=>{
      if(!drawMode) return;
      endDrawing();
    });
    map.on('movestart', ()=>{ if(drawing){ endDrawing(); } });

    // Auto-route within perimeter (simple nearest-neighbor visiting pins inside)
    document.getElementById('autoRouteBtn').addEventListener('click', ()=>{
      if(!parking){ alert('Set parking first.'); return; }
      if(!perimeter || perimeter.length<3){ alert('Draw a perimeter first.'); return; }
      const insidePins = Array.from(pins.values()).filter(p=>pointInPolygon([p.lat,p.lng], perimeter.map(ll=>[ll.lat,ll.lng])));
      if(insidePins.length===0){ alert('No pins inside perimeter.'); return; }
      const route = [parking]; // start at car
      let cur = {lat: parking.lat, lng: parking.lng};
      const remaining = insidePins.slice();
      while(remaining.length){
        let bestIdx=0, bestD=Infinity;
        for(let i=0;i<remaining.length;i++){
          const d = distM(cur, {lat:remaining[i].lat, lng:remaining[i].lng});
          if(d<bestD){ bestD=d; bestIdx=i; }
        }
        const nxt=remaining.splice(bestIdx,1)[0];
        route.push({lat:nxt.lat, lng:nxt.lng}); cur={lat:nxt.lat,lng:nxt.lng};
      }
      route.push(parking); // end at car
      routePoints = route; renderRoute();
    });

    // Ray-casting point in polygon
    function pointInPolygon(pt, poly){
      const x=pt[1], y=pt[0];
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const xi=poly[i][1], yi=poly[i][0], xj=poly[j][1], yj=poly[j][0];
        const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }

    // Render initial stuff
    renderParking();
    renderPerimeter();
    renderRoute();

    // Export/Import/Clear pins
    document.getElementById('exportBtn').addEventListener('click', ()=>{
      const data = JSON.stringify(Array.from(pins.values()).map(({_marker,_chain,...rest})=>rest), null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='sales_route_pins.json'; a.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById('importBtn').addEventListener('click', ()=>document.getElementById('importFile').click());
    document.getElementById('importFile').addEventListener('change', ev=>{
      const file = ev.target.files[0]; if(!file) return;
      const r = new FileReader(); r.onload = ()=>{ try{
        const arr = JSON.parse(r.result);
        pins.forEach(p=>{ if(p._marker) map.removeLayer(p._marker); }); pins.clear();
        arr.forEach(obj=>{ const p={...obj, id: obj.id||newId()}; pins.set(p.id,p); createMarker(p); });
        savePins(); toast('Pins imported');
      } catch(err){ alert('Import failed: '+err.message); } };
      r.readAsText(file);
    });
    document.getElementById('clearPinsBtn').addEventListener('click', ()=>{
      pins.forEach(p=>{ if(p._marker) map.removeLayer(p._marker); });
      pins.clear(); savePins(); toast('Pins cleared');
    });

    // Live tracking & auto-visit unchanged for brevity
    if(navigator.geolocation){
      navigator.geolocation.watchPosition(pos=>{
        const latlng = {lat:pos.coords.latitude, lng:pos.coords.longitude};
        if(youAreHere){ youAreHere.setLatLng(latlng); } else { youAreHere = L.marker(latlng).addTo(map).bindPopup('You are here'); }
        if(routePoints.length>=2){
          const proj = projectPointToPolyline(latlng, routePoints);
          if(proj.ok){
            if(document.getElementById('tglProgress').checked){
              updateProgressPolyline(proj.alongM);
            } else if(progressPoly){ progressPoly.setLatLngs([]); }
            if(document.getElementById('tglAutoVisit').checked){
              const distLimit = parseFloat(document.getElementById('autoVisitInput').value||35);
              // Project pins once lazily
              pins.forEach(p=>{
                if(p.status==='VISITED' || p.keepUnvisited) return;
                const projP = projectPointToPolyline({lat:p.lat,lng:p.lng}, routePoints);
                if(projP.ok && projP.perpM<=distLimit && proj.alongM>=projP.alongM){
                  p.status='VISITED'; updateMarker(p); savePins();
                }
              });
            }
          }
        }
      }, err=>console.warn(err), {enableHighAccuracy:true, maximumAge:5000, timeout:10000});
    }
    function projectPointToPolyline(P, line){
      if(!line || line.length<2) return {ok:false};
      let best={ok:false, perpM:Infinity, alongM:0, proj:null}; let cum=0;
      for(let i=0;i<line.length-1;i++){
        const A=line[i], B=line[i+1];
        const res = projectPointToSegment(P,A,B,cum);
        if(res.perpM<best.perpM){ best=res; } cum=res.cumNext;
      }
      return best;
    }
    function projectPointToSegment(P,A,B,cumBefore){
      const mapA=map.latLngToLayerPoint(A), mapB=map.latLngToLayerPoint(B), mapP=map.latLngToLayerPoint(P);
      const AB={x:mapB.x-mapA.x,y:mapB.y-mapA.y}, AP={x:mapP.x-mapA.x,y:mapP.y-mapA.y};
      const ab2 = AB.x*AB.x+AB.y*AB.y; let t = ab2===0?0:(AP.x*AB.x+AP.y*AB.y)/ab2; t=Math.max(0,Math.min(1,t));
      const projPx={x:mapA.x+t*AB.x,y:mapA.y+t*AB.y}; const projLL=map.layerPointToLatLng(projPx);
      const segLen=distM(A,B); const perpM=distM(P,projLL); const alongM=cumBefore+segLen*t;
      return {ok:true, proj:projLL, perpM, alongM, cumNext:cumBefore+segLen};
    }
    function updateProgressPolyline(alongM){
      if(routePoints.length<2){ return; }
      if(!progressPoly){ progressPoly = L.polyline([], {color:'#27ae60', weight:6, opacity:0.9}).addTo(map); }
      const out=[]; let remain=alongM;
      for(let i=0;i<routePoints.length-1;i++){
        const A=routePoints[i], B=routePoints[i+1]; const seg=distM(A,B);
        if(remain<=0) break;
        if(remain>=seg){ if(out.length===0) out.push(A); out.push(B); remain-=seg; }
        else { if(out.length===0) out.push(A);
          const t=remain/seg; const pA=map.latLngToLayerPoint(A), pB=map.latLngToLayerPoint(B);
          const pX={x:pA.x+t*(pB.x-pA.x), y:pA.y+t*(pB.y-pA.y)}; out.push(map.layerPointToLatLng(pX)); break; }
      }
      progressPoly.setLatLngs(out);
    }
  </script>
</body>
</html>
